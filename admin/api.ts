/* tslint:disable */
/* eslint-disable */
/**
 * Nestbox API Admin
 * API for Nestbox Admin, control your resources
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddProjectMemberData
 */
export interface AddProjectMemberData {
    /**
     * 
     * @type {string}
     * @memberof AddProjectMemberData
     */
    'message': string;
    /**
     * 
     * @type {object}
     * @memberof AddProjectMemberData
     */
    'project': object;
}
/**
 * 
 * @export
 * @interface AddProjectMemberDto
 */
export interface AddProjectMemberDto {
    /**
     * 
     * @type {string}
     * @memberof AddProjectMemberDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AddProjectMemberDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof AddProjectMemberDto
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof AddProjectMemberDto
     */
    'roleId': number;
}
/**
 * 
 * @export
 * @interface AddProjectMemberResponseDTO
 */
export interface AddProjectMemberResponseDTO {
    /**
     * 
     * @type {AddProjectMemberData}
     * @memberof AddProjectMemberResponseDTO
     */
    'data': AddProjectMemberData;
}
/**
 * 
 * @export
 * @interface AllProjectResponse
 */
export interface AllProjectResponse {
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'deletedAt': string;
}
/**
 * 
 * @export
 * @interface AllProjectResponseModel
 */
export interface AllProjectResponseModel {
    /**
     * 
     * @type {Array<AllProjectResponse>}
     * @memberof AllProjectResponseModel
     */
    'projects': Array<AllProjectResponse>;
    /**
     * 
     * @type {number}
     * @memberof AllProjectResponseModel
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface BadRequestExceptionResponse
 */
export interface BadRequestExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof BadRequestExceptionResponse
     */
    'message': string;
    /**
     * 
     * @type {object}
     * @memberof BadRequestExceptionResponse
     */
    'errors': object | null;
}
/**
 * 
 * @export
 * @interface BooleanResponseDTO
 */
export interface BooleanResponseDTO {
    /**
     * 
     * @type {boolean}
     * @memberof BooleanResponseDTO
     */
    'data': boolean;
}
/**
 * 
 * @export
 * @interface CreateDeviceRequestDTO
 */
export interface CreateDeviceRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateDeviceRequestDTO
     */
    'type': CreateDeviceRequestDTOTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateDeviceRequestDTO
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateDeviceRequestDTO
     */
    'userAgent'?: string;
}

export const CreateDeviceRequestDTOTypeEnum = {
    Web: 'WEB',
    Android: 'ANDROID',
    Ios: 'IOS'
} as const;

export type CreateDeviceRequestDTOTypeEnum = typeof CreateDeviceRequestDTOTypeEnum[keyof typeof CreateDeviceRequestDTOTypeEnum];

/**
 * 
 * @export
 * @interface CreateDeviceResponseDTO
 */
export interface CreateDeviceResponseDTO {
    /**
     * 
     * @type {number}
     * @memberof CreateDeviceResponseDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateDeviceResponseDTO
     */
    'uuid': string;
    /**
     * 
     * @type {number}
     * @memberof CreateDeviceResponseDTO
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateDeviceResponseDTO
     */
    'type': CreateDeviceResponseDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateDeviceResponseDTO
     */
    'userAgent': string;
}

export const CreateDeviceResponseDTOTypeEnum = {
    Web: 'WEB',
    Android: 'ANDROID',
    Ios: 'IOS'
} as const;

export type CreateDeviceResponseDTOTypeEnum = typeof CreateDeviceResponseDTOTypeEnum[keyof typeof CreateDeviceResponseDTOTypeEnum];

/**
 * 
 * @export
 * @interface CreateMachineAgentDto
 */
export interface CreateMachineAgentDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'agentName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'goal': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'modelBaseId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'machineName': string;
    /**
     * 
     * @type {number}
     * @memberof CreateMachineAgentDto
     */
    'machineInstanceId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'instanceIP': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'entryFunctionName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'machineManifestId': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof CreateMachineAgentDto
     */
    'parameters': Array<object>;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'projectId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateMachineAgentDto
     */
    'userId': number;
}
/**
 * 
 * @export
 * @interface CreatePermissionDto
 */
export interface CreatePermissionDto {
    /**
     * 
     * @type {boolean}
     * @memberof CreatePermissionDto
     */
    'read': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePermissionDto
     */
    'write': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePermissionDto
     */
    'update': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePermissionDto
     */
    'delete': boolean;
}
/**
 * 
 * @export
 * @interface CreateProjectDTO
 */
export interface CreateProjectDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateProjectDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectDTO
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CreateProjectResponseDTO
 */
export interface CreateProjectResponseDTO {
    /**
     * 
     * @type {ProjectResponseModel}
     * @memberof CreateProjectResponseDTO
     */
    'data': ProjectResponseModel;
}
/**
 * 
 * @export
 * @interface CreateProjectRoleResponseDto
 */
export interface CreateProjectRoleResponseDto {
    /**
     * 
     * @type {CreateRoleDTO}
     * @memberof CreateProjectRoleResponseDto
     */
    'data': CreateRoleDTO;
}
/**
 * 
 * @export
 * @interface CreateResourceDto
 */
export interface CreateResourceDto {
    /**
     * 
     * @type {string}
     * @memberof CreateResourceDto
     */
    'name': string;
    /**
     * 
     * @type {Array<CreatePermissionDto>}
     * @memberof CreateResourceDto
     */
    'permissions': Array<CreatePermissionDto>;
}
/**
 * 
 * @export
 * @interface CreateRoleDTO
 */
export interface CreateRoleDTO {
    /**
     * 
     * @type {number}
     * @memberof CreateRoleDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleDTO
     */
    'description': string;
    /**
     * 
     * @type {Array<ResourceDTO>}
     * @memberof CreateRoleDTO
     */
    'resources': Array<ResourceDTO>;
}
/**
 * 
 * @export
 * @interface CreateRoleDto
 */
export interface CreateRoleDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRoleDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleDto
     */
    'description': string;
    /**
     * 
     * @type {Array<CreateResourceDto>}
     * @memberof CreateRoleDto
     */
    'resources': Array<CreateResourceDto>;
}
/**
 * 
 * @export
 * @interface CreateWebhookDto
 */
export interface CreateWebhookDto {
    /**
     * The URL for the webhook
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'url': string;
    /**
     * Comma-separated notifications. Valid values: QUERY_CREATED, QUERY_COMPLETED, QUERY_FAILED, EVENT_CREATED, EVENT_UPDATED
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'notifications': string;
}
/**
 * 
 * @export
 * @interface DeleteProjectDto
 */
export interface DeleteProjectDto {
    /**
     * 
     * @type {string}
     * @memberof DeleteProjectDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DeleteProjectResponseDTO
 */
export interface DeleteProjectResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof DeleteProjectResponseDTO
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DeleteProjectRoleByIdResponseDto
 */
export interface DeleteProjectRoleByIdResponseDto {
    /**
     * 
     * @type {DeleteProjectDto}
     * @memberof DeleteProjectRoleByIdResponseDto
     */
    'data': DeleteProjectDto;
}
/**
 * 
 * @export
 * @interface FatalErrorExceptionResponse
 */
export interface FatalErrorExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof FatalErrorExceptionResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface FindUsersResponseDTO
 */
export interface FindUsersResponseDTO {
    /**
     * 
     * @type {Array<UserResponseModel>}
     * @memberof FindUsersResponseDTO
     */
    'data': Array<UserResponseModel>;
    /**
     * 
     * @type {number}
     * @memberof FindUsersResponseDTO
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ForbiddenExceptionResponse
 */
export interface ForbiddenExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof ForbiddenExceptionResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ForgetPasswordRequestDTO
 */
export interface ForgetPasswordRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ForgetPasswordRequestDTO
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ForgetPasswordResponseDTO
 */
export interface ForgetPasswordResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof ForgetPasswordResponseDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ForgetPasswordVerificationRequestDTO
 */
export interface ForgetPasswordVerificationRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ForgetPasswordVerificationRequestDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ForgetPasswordVerificationResponseDTO
 */
export interface ForgetPasswordVerificationResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof ForgetPasswordVerificationResponseDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface GetAllProjectDto
 */
export interface GetAllProjectDto {
    /**
     * 
     * @type {Array<GetAllRoleDTO>}
     * @memberof GetAllProjectDto
     */
    'roles': Array<GetAllRoleDTO>;
    /**
     * 
     * @type {number}
     * @memberof GetAllProjectDto
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface GetAllProjectMemberResponse
 */
export interface GetAllProjectMemberResponse {
    /**
     * 
     * @type {Array<TeamMemberDto>}
     * @memberof GetAllProjectMemberResponse
     */
    'teamMembers': Array<TeamMemberDto>;
    /**
     * 
     * @type {number}
     * @memberof GetAllProjectMemberResponse
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface GetAllProjectMemberResponseDto
 */
export interface GetAllProjectMemberResponseDto {
    /**
     * 
     * @type {GetAllProjectMemberResponse}
     * @memberof GetAllProjectMemberResponseDto
     */
    'data': GetAllProjectMemberResponse;
}
/**
 * 
 * @export
 * @interface GetAllProjectRoleResponseDto
 */
export interface GetAllProjectRoleResponseDto {
    /**
     * 
     * @type {GetAllProjectDto}
     * @memberof GetAllProjectRoleResponseDto
     */
    'data': GetAllProjectDto;
}
/**
 * 
 * @export
 * @interface GetAllProjectsResponseDTO
 */
export interface GetAllProjectsResponseDTO {
    /**
     * 
     * @type {AllProjectResponseModel}
     * @memberof GetAllProjectsResponseDTO
     */
    'data': AllProjectResponseModel;
}
/**
 * 
 * @export
 * @interface GetAllRoleDTO
 */
export interface GetAllRoleDTO {
    /**
     * 
     * @type {number}
     * @memberof GetAllRoleDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'deletedAt': string;
}
/**
 * 
 * @export
 * @interface GetMeResponseDTO
 */
export interface GetMeResponseDTO {
    /**
     * 
     * @type {number}
     * @memberof GetMeResponseDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetMeResponseDTO
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeResponseDTO
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeResponseDTO
     */
    'type': GetMeResponseDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetMeResponseDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeResponseDTO
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeResponseDTO
     */
    'status': GetMeResponseDTOStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof GetMeResponseDTO
     */
    'profilePictureId': number;
    /**
     * 
     * @type {UserSettingsModel}
     * @memberof GetMeResponseDTO
     */
    'settings': UserSettingsModel;
    /**
     * 
     * @type {string}
     * @memberof GetMeResponseDTO
     */
    'bio': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeResponseDTO
     */
    'profilePictureUrl': string;
}

export const GetMeResponseDTOTypeEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type GetMeResponseDTOTypeEnum = typeof GetMeResponseDTOTypeEnum[keyof typeof GetMeResponseDTOTypeEnum];
export const GetMeResponseDTOStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type GetMeResponseDTOStatusEnum = typeof GetMeResponseDTOStatusEnum[keyof typeof GetMeResponseDTOStatusEnum];

/**
 * 
 * @export
 * @interface GetProjectByIDResponseDTO
 */
export interface GetProjectByIDResponseDTO {
    /**
     * 
     * @type {ProjectResponseModel}
     * @memberof GetProjectByIDResponseDTO
     */
    'data': ProjectResponseModel;
}
/**
 * 
 * @export
 * @interface GetProjectRoleByIdResponseDto
 */
export interface GetProjectRoleByIdResponseDto {
    /**
     * 
     * @type {GetRoleDTO}
     * @memberof GetProjectRoleByIdResponseDto
     */
    'data': GetRoleDTO;
}
/**
 * 
 * @export
 * @interface GetRoleDTO
 */
export interface GetRoleDTO {
    /**
     * 
     * @type {number}
     * @memberof GetRoleDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetRoleDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetRoleDTO
     */
    'description': string;
    /**
     * 
     * @type {Array<ResourceDTO>}
     * @memberof GetRoleDTO
     */
    'resources': Array<ResourceDTO>;
}
/**
 * 
 * @export
 * @interface GetUserByIdResponseDTO
 */
export interface GetUserByIdResponseDTO {
    /**
     * 
     * @type {number}
     * @memberof GetUserByIdResponseDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetUserByIdResponseDTO
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserByIdResponseDTO
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserByIdResponseDTO
     */
    'type': GetUserByIdResponseDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetUserByIdResponseDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserByIdResponseDTO
     */
    'bio': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserByIdResponseDTO
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserByIdResponseDTO
     */
    'status': GetUserByIdResponseDTOStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof GetUserByIdResponseDTO
     */
    'profilePictureId': number;
    /**
     * 
     * @type {MediaResponseModel}
     * @memberof GetUserByIdResponseDTO
     */
    'profilePicture': MediaResponseModel;
    /**
     * 
     * @type {string}
     * @memberof GetUserByIdResponseDTO
     */
    'profilePictureUrl': string;
}

export const GetUserByIdResponseDTOTypeEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type GetUserByIdResponseDTOTypeEnum = typeof GetUserByIdResponseDTOTypeEnum[keyof typeof GetUserByIdResponseDTOTypeEnum];
export const GetUserByIdResponseDTOStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type GetUserByIdResponseDTOStatusEnum = typeof GetUserByIdResponseDTOStatusEnum[keyof typeof GetUserByIdResponseDTOStatusEnum];

/**
 * 
 * @export
 * @interface GetUserProjectRoleByRoleIdResponseDto
 */
export interface GetUserProjectRoleByRoleIdResponseDto {
    /**
     * 
     * @type {GetRoleDTO}
     * @memberof GetUserProjectRoleByRoleIdResponseDto
     */
    'data': GetRoleDTO;
}
/**
 * 
 * @export
 * @interface LoginRequestDTO
 */
export interface LoginRequestDTO {
    /**
     * Email
     * @type {string}
     * @memberof LoginRequestDTO
     */
    'email': string;
    /**
     * Password
     * @type {string}
     * @memberof LoginRequestDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponseDTO
 */
export interface LoginResponseDTO {
    /**
     * Token
     * @type {string}
     * @memberof LoginResponseDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface MediaResponseModel
 */
export interface MediaResponseModel {
    /**
     * 
     * @type {number}
     * @memberof MediaResponseModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    'extension': string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    'type': MediaResponseModelTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    'access': MediaResponseModelAccessEnum;
    /**
     * 
     * @type {number}
     * @memberof MediaResponseModel
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    'thumbPath': string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    'status': MediaResponseModelStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof MediaResponseModel
     */
    'userId': number;
    /**
     * 
     * @type {object}
     * @memberof MediaResponseModel
     */
    'meta': object;
}

export const MediaResponseModelTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Document: 'DOCUMENT',
    Archive: 'ARCHIVE',
    Other: 'OTHER'
} as const;

export type MediaResponseModelTypeEnum = typeof MediaResponseModelTypeEnum[keyof typeof MediaResponseModelTypeEnum];
export const MediaResponseModelAccessEnum = {
    Public: 'PUBLIC',
    Private: 'PRIVATE'
} as const;

export type MediaResponseModelAccessEnum = typeof MediaResponseModelAccessEnum[keyof typeof MediaResponseModelAccessEnum];
export const MediaResponseModelStatusEnum = {
    Uploading: 'UPLOADING',
    Ready: 'READY',
    Stale: 'STALE'
} as const;

export type MediaResponseModelStatusEnum = typeof MediaResponseModelStatusEnum[keyof typeof MediaResponseModelStatusEnum];

/**
 * 
 * @export
 * @interface NotFoundExceptionResponse
 */
export interface NotFoundExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof NotFoundExceptionResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface OAuthLoginRequestDTO
 */
export interface OAuthLoginRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof OAuthLoginRequestDTO
     */
    'providerId': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthLoginRequestDTO
     */
    'type': OAuthLoginRequestDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OAuthLoginRequestDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthLoginRequestDTO
     */
    'profilePictureUrl': string;
}

export const OAuthLoginRequestDTOTypeEnum = {
    Google: 'GOOGLE',
    Apple: 'APPLE'
} as const;

export type OAuthLoginRequestDTOTypeEnum = typeof OAuthLoginRequestDTOTypeEnum[keyof typeof OAuthLoginRequestDTOTypeEnum];

/**
 * 
 * @export
 * @interface PermissionsDTO
 */
export interface PermissionsDTO {
    /**
     * 
     * @type {number}
     * @memberof PermissionsDTO
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsDTO
     */
    'read': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsDTO
     */
    'write': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsDTO
     */
    'update': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsDTO
     */
    'delete': boolean;
}
/**
 * 
 * @export
 * @interface ProjectResponseModel
 */
export interface ProjectResponseModel {
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'deletedAt': string;
}
/**
 * 
 * @export
 * @interface RegisteredUserResponseDTO
 */
export interface RegisteredUserResponseDTO {
    /**
     * registered
     * @type {boolean}
     * @memberof RegisteredUserResponseDTO
     */
    'registered': boolean;
}
/**
 * 
 * @export
 * @interface ResetPasswordRequestDTO
 */
export interface ResetPasswordRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequestDTO
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequestDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ResourceDTO
 */
export interface ResourceDTO {
    /**
     * 
     * @type {number}
     * @memberof ResourceDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ResourceDTO
     */
    'name': string;
    /**
     * 
     * @type {Array<PermissionsDTO>}
     * @memberof ResourceDTO
     */
    'permissions': Array<PermissionsDTO>;
}
/**
 * 
 * @export
 * @interface RoleDto
 */
export interface RoleDto {
    /**
     * 
     * @type {number}
     * @memberof RoleDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RoleDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SignupRequestDTO
 */
export interface SignupRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'providerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'providerType'?: SignupRequestDTOProviderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'profilePictureUrl': string;
}

export const SignupRequestDTOProviderTypeEnum = {
    Google: 'GOOGLE',
    Apple: 'APPLE'
} as const;

export type SignupRequestDTOProviderTypeEnum = typeof SignupRequestDTOProviderTypeEnum[keyof typeof SignupRequestDTOProviderTypeEnum];

/**
 * 
 * @export
 * @interface SignupResponseDTO
 */
export interface SignupResponseDTO {
    /**
     * Token
     * @type {string}
     * @memberof SignupResponseDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TeamMemberDto
 */
export interface TeamMemberDto {
    /**
     * 
     * @type {number}
     * @memberof TeamMemberDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDto
     */
    'status': string;
    /**
     * 
     * @type {UserDto}
     * @memberof TeamMemberDto
     */
    'user': UserDto;
    /**
     * 
     * @type {RoleDto}
     * @memberof TeamMemberDto
     */
    'role': RoleDto;
}
/**
 * 
 * @export
 * @interface UnauthorizedExceptionResponse
 */
export interface UnauthorizedExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof UnauthorizedExceptionResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpdatePermissionDto
 */
export interface UpdatePermissionDto {
    /**
     * 
     * @type {number}
     * @memberof UpdatePermissionDto
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePermissionDto
     */
    'read': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePermissionDto
     */
    'write': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePermissionDto
     */
    'update': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePermissionDto
     */
    'delete': boolean;
}
/**
 * 
 * @export
 * @interface UpdateProjectByIDResponseDTO
 */
export interface UpdateProjectByIDResponseDTO {
    /**
     * 
     * @type {ProjectResponseModel}
     * @memberof UpdateProjectByIDResponseDTO
     */
    'data': ProjectResponseModel;
}
/**
 * 
 * @export
 * @interface UpdateProjectByIdRequest
 */
export interface UpdateProjectByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectByIdRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectByIdRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface UpdateProjectRoleResponseDto
 */
export interface UpdateProjectRoleResponseDto {
    /**
     * 
     * @type {UpdateRoleDTO}
     * @memberof UpdateProjectRoleResponseDto
     */
    'data': UpdateRoleDTO;
}
/**
 * 
 * @export
 * @interface UpdateResourceDto
 */
export interface UpdateResourceDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateResourceDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceDto
     */
    'name': string;
    /**
     * 
     * @type {Array<UpdatePermissionDto>}
     * @memberof UpdateResourceDto
     */
    'permissions': Array<UpdatePermissionDto>;
}
/**
 * 
 * @export
 * @interface UpdateRoleByIdDto
 */
export interface UpdateRoleByIdDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleByIdDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleByIdDto
     */
    'description': string;
    /**
     * 
     * @type {Array<UpdateResourceDto>}
     * @memberof UpdateRoleByIdDto
     */
    'resources': Array<UpdateResourceDto>;
}
/**
 * 
 * @export
 * @interface UpdateRoleDTO
 */
export interface UpdateRoleDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdateRoleDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleDTO
     */
    'description': string;
    /**
     * 
     * @type {Array<ResourceDTO>}
     * @memberof UpdateRoleDTO
     */
    'resources': Array<ResourceDTO>;
}
/**
 * 
 * @export
 * @interface UpdateTeamMemberRequestDTO
 */
export interface UpdateTeamMemberRequestDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdateTeamMemberRequestDTO
     */
    'roleId': number;
}
/**
 * 
 * @export
 * @interface UpdateTeamMemberStatusRequestDTO
 */
export interface UpdateTeamMemberStatusRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamMemberStatusRequestDTO
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamMemberStatusRequestDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface UpdateUserRequestDTO
 */
export interface UpdateUserRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestDTO
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestDTO
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestDTO
     */
    'bio': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestDTO
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestDTO
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserSettingsRequestDTO
 */
export interface UpdateUserSettingsRequestDTO {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserSettingsRequestDTO
     */
    'notificationsEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UploadFinalizeMediaRequestDTO
 */
export interface UploadFinalizeMediaRequestDTO {
    /**
     * 
     * @type {number}
     * @memberof UploadFinalizeMediaRequestDTO
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface UploadFinalizeMediaResponseDTO
 */
export interface UploadFinalizeMediaResponseDTO {
    /**
     * 
     * @type {number}
     * @memberof UploadFinalizeMediaResponseDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UploadFinalizeMediaResponseDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UploadFinalizeMediaResponseDTO
     */
    'extension': string;
    /**
     * 
     * @type {string}
     * @memberof UploadFinalizeMediaResponseDTO
     */
    'type': UploadFinalizeMediaResponseDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UploadFinalizeMediaResponseDTO
     */
    'access': UploadFinalizeMediaResponseDTOAccessEnum;
    /**
     * 
     * @type {number}
     * @memberof UploadFinalizeMediaResponseDTO
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof UploadFinalizeMediaResponseDTO
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof UploadFinalizeMediaResponseDTO
     */
    'thumbPath': string;
    /**
     * 
     * @type {string}
     * @memberof UploadFinalizeMediaResponseDTO
     */
    'status': UploadFinalizeMediaResponseDTOStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof UploadFinalizeMediaResponseDTO
     */
    'userId': number;
    /**
     * 
     * @type {object}
     * @memberof UploadFinalizeMediaResponseDTO
     */
    'meta': object;
}

export const UploadFinalizeMediaResponseDTOTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Document: 'DOCUMENT',
    Archive: 'ARCHIVE',
    Other: 'OTHER'
} as const;

export type UploadFinalizeMediaResponseDTOTypeEnum = typeof UploadFinalizeMediaResponseDTOTypeEnum[keyof typeof UploadFinalizeMediaResponseDTOTypeEnum];
export const UploadFinalizeMediaResponseDTOAccessEnum = {
    Public: 'PUBLIC',
    Private: 'PRIVATE'
} as const;

export type UploadFinalizeMediaResponseDTOAccessEnum = typeof UploadFinalizeMediaResponseDTOAccessEnum[keyof typeof UploadFinalizeMediaResponseDTOAccessEnum];
export const UploadFinalizeMediaResponseDTOStatusEnum = {
    Uploading: 'UPLOADING',
    Ready: 'READY',
    Stale: 'STALE'
} as const;

export type UploadFinalizeMediaResponseDTOStatusEnum = typeof UploadFinalizeMediaResponseDTOStatusEnum[keyof typeof UploadFinalizeMediaResponseDTOStatusEnum];

/**
 * 
 * @export
 * @interface UploadInitiateMediaRequestDTO
 */
export interface UploadInitiateMediaRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof UploadInitiateMediaRequestDTO
     */
    'name': string;
    /**
     * Size in KB
     * @type {number}
     * @memberof UploadInitiateMediaRequestDTO
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof UploadInitiateMediaRequestDTO
     */
    'type': UploadInitiateMediaRequestDTOTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UploadInitiateMediaRequestDTO
     */
    'public'?: boolean;
}

export const UploadInitiateMediaRequestDTOTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Document: 'DOCUMENT',
    Archive: 'ARCHIVE',
    Other: 'OTHER'
} as const;

export type UploadInitiateMediaRequestDTOTypeEnum = typeof UploadInitiateMediaRequestDTOTypeEnum[keyof typeof UploadInitiateMediaRequestDTOTypeEnum];

/**
 * 
 * @export
 * @interface UploadInitiateMediaResponseDTO
 */
export interface UploadInitiateMediaResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof UploadInitiateMediaResponseDTO
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof UploadInitiateMediaResponseDTO
     */
    'secretAccessKey': string;
    /**
     * 
     * @type {string}
     * @memberof UploadInitiateMediaResponseDTO
     */
    'sessionToken': string;
    /**
     * 
     * @type {number}
     * @memberof UploadInitiateMediaResponseDTO
     */
    'mediaId': number;
    /**
     * 
     * @type {string}
     * @memberof UploadInitiateMediaResponseDTO
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof UploadInitiateMediaResponseDTO
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof UploadInitiateMediaResponseDTO
     */
    'region': string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'profilePicture': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'bio': string;
}
/**
 * 
 * @export
 * @interface UserResponseModel
 */
export interface UserResponseModel {
    /**
     * 
     * @type {number}
     * @memberof UserResponseModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserResponseModel
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseModel
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseModel
     */
    'type': UserResponseModelTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserResponseModel
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseModel
     */
    'bio': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseModel
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseModel
     */
    'status': UserResponseModelStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof UserResponseModel
     */
    'profilePictureId': number;
    /**
     * 
     * @type {MediaResponseModel}
     * @memberof UserResponseModel
     */
    'profilePicture': MediaResponseModel;
    /**
     * 
     * @type {string}
     * @memberof UserResponseModel
     */
    'profilePictureUrl': string;
}

export const UserResponseModelTypeEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type UserResponseModelTypeEnum = typeof UserResponseModelTypeEnum[keyof typeof UserResponseModelTypeEnum];
export const UserResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type UserResponseModelStatusEnum = typeof UserResponseModelStatusEnum[keyof typeof UserResponseModelStatusEnum];

/**
 * 
 * @export
 * @interface UserSettingsModel
 */
export interface UserSettingsModel {
    /**
     * 
     * @type {boolean}
     * @memberof UserSettingsModel
     */
    'notificationsEnabled': boolean;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Forget password initiate
         * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPassword: async (forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgetPasswordRequestDTO' is not null or undefined
            assertParamExists('authControllerForgetPassword', 'forgetPasswordRequestDTO', forgetPasswordRequestDTO)
            const localVarPath = `/auth/forget-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgetPasswordRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forget password verification
         * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPasswordVerification: async (forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgetPasswordVerificationRequestDTO' is not null or undefined
            assertParamExists('authControllerForgetPasswordVerification', 'forgetPasswordVerificationRequestDTO', forgetPasswordVerificationRequestDTO)
            const localVarPath = `/auth/forget-password/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgetPasswordVerificationRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login to the application
         * @param {LoginRequestDTO} loginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginRequestDTO: LoginRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequestDTO' is not null or undefined
            assertParamExists('authControllerLogin', 'loginRequestDTO', loginRequestDTO)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login with OAuth apps
         * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerOAuthLogin: async (oAuthLoginRequestDTO: OAuthLoginRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthLoginRequestDTO' is not null or undefined
            assertParamExists('authControllerOAuthLogin', 'oAuthLoginRequestDTO', oAuthLoginRequestDTO)
            const localVarPath = `/auth/login/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthLoginRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword: async (resetPasswordRequestDTO: ResetPasswordRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequestDTO' is not null or undefined
            assertParamExists('authControllerResetPassword', 'resetPasswordRequestDTO', resetPasswordRequestDTO)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Signup in the application
         * @param {SignupRequestDTO} signupRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup: async (signupRequestDTO: SignupRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequestDTO' is not null or undefined
            assertParamExists('authControllerSignup', 'signupRequestDTO', signupRequestDTO)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Forget password initiate
         * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerForgetPassword(forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgetPasswordResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerForgetPassword(forgetPasswordRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerForgetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forget password verification
         * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgetPasswordVerificationResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerForgetPasswordVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login to the application
         * @param {LoginRequestDTO} loginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login with OAuth apps
         * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerOAuthLogin(oAuthLoginRequestDTO: OAuthLoginRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerOAuthLogin(oAuthLoginRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerOAuthLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPassword(resetPasswordRequestDTO: ResetPasswordRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPassword(resetPasswordRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerResetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Signup in the application
         * @param {SignupRequestDTO} signupRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignup(signupRequestDTO: SignupRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignupResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignup(signupRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Forget password initiate
         * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPassword(forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<ForgetPasswordResponseDTO> {
            return localVarFp.authControllerForgetPassword(forgetPasswordRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forget password verification
         * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<ForgetPasswordVerificationResponseDTO> {
            return localVarFp.authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login to the application
         * @param {LoginRequestDTO} loginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseDTO> {
            return localVarFp.authControllerLogin(loginRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login with OAuth apps
         * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerOAuthLogin(oAuthLoginRequestDTO: OAuthLoginRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseDTO> {
            return localVarFp.authControllerOAuthLogin(oAuthLoginRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword(resetPasswordRequestDTO: ResetPasswordRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseDTO> {
            return localVarFp.authControllerResetPassword(resetPasswordRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Signup in the application
         * @param {SignupRequestDTO} signupRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup(signupRequestDTO: SignupRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<SignupResponseDTO> {
            return localVarFp.authControllerSignup(signupRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Forget password initiate
     * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerForgetPassword(forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerForgetPassword(forgetPasswordRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forget password verification
     * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login to the application
     * @param {LoginRequestDTO} loginRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login with OAuth apps
     * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerOAuthLogin(oAuthLoginRequestDTO: OAuthLoginRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerOAuthLogin(oAuthLoginRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forget password initiate
     * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerResetPassword(resetPasswordRequestDTO: ResetPasswordRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResetPassword(resetPasswordRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Signup in the application
     * @param {SignupRequestDTO} signupRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignup(signupRequestDTO: SignupRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignup(signupRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appControllerGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetHello(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeviceApi - axios parameter creator
 * @export
 */
export const DeviceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new device
         * @param {CreateDeviceRequestDTO} createDeviceRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerCreate: async (createDeviceRequestDTO: CreateDeviceRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDeviceRequestDTO' is not null or undefined
            assertParamExists('deviceControllerCreate', 'createDeviceRequestDTO', createDeviceRequestDTO)
            const localVarPath = `/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApi - functional programming interface
 * @export
 */
export const DeviceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new device
         * @param {CreateDeviceRequestDTO} createDeviceRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceControllerCreate(createDeviceRequestDTO: CreateDeviceRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDeviceResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceControllerCreate(createDeviceRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.deviceControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeviceApi - factory interface
 * @export
 */
export const DeviceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new device
         * @param {CreateDeviceRequestDTO} createDeviceRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerCreate(createDeviceRequestDTO: CreateDeviceRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<CreateDeviceResponseDTO> {
            return localVarFp.deviceControllerCreate(createDeviceRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceApi - object-oriented interface
 * @export
 * @class DeviceApi
 * @extends {BaseAPI}
 */
export class DeviceApi extends BaseAPI {
    /**
     * 
     * @summary Create a new device
     * @param {CreateDeviceRequestDTO} createDeviceRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public deviceControllerCreate(createDeviceRequestDTO: CreateDeviceRequestDTO, options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).deviceControllerCreate(createDeviceRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MachineImagesApi - axios parameter creator
 * @export
 */
export const MachineImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineImagesControllerGetJsonData: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/machineImages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MachineImagesApi - functional programming interface
 * @export
 */
export const MachineImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MachineImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineImagesControllerGetJsonData(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineImagesControllerGetJsonData(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineImagesApi.machineImagesControllerGetJsonData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MachineImagesApi - factory interface
 * @export
 */
export const MachineImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MachineImagesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineImagesControllerGetJsonData(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.machineImagesControllerGetJsonData(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MachineImagesApi - object-oriented interface
 * @export
 * @class MachineImagesApi
 * @extends {BaseAPI}
 */
export class MachineImagesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineImagesApi
     */
    public machineImagesControllerGetJsonData(options?: RawAxiosRequestConfig) {
        return MachineImagesApiFp(this.configuration).machineImagesControllerGetJsonData(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Finalize media
         * @param {UploadFinalizeMediaRequestDTO} uploadFinalizeMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaControllerUploadFinalize: async (uploadFinalizeMediaRequestDTO: UploadFinalizeMediaRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadFinalizeMediaRequestDTO' is not null or undefined
            assertParamExists('mediaControllerUploadFinalize', 'uploadFinalizeMediaRequestDTO', uploadFinalizeMediaRequestDTO)
            const localVarPath = `/media/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadFinalizeMediaRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload media
         * @param {UploadInitiateMediaRequestDTO} uploadInitiateMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaControllerUploadInitiate: async (uploadInitiateMediaRequestDTO: UploadInitiateMediaRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadInitiateMediaRequestDTO' is not null or undefined
            assertParamExists('mediaControllerUploadInitiate', 'uploadInitiateMediaRequestDTO', uploadInitiateMediaRequestDTO)
            const localVarPath = `/media/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadInitiateMediaRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finalize public media
         * @param {UploadFinalizeMediaRequestDTO} uploadFinalizeMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaControllerUploadPublicFinalize: async (uploadFinalizeMediaRequestDTO: UploadFinalizeMediaRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadFinalizeMediaRequestDTO' is not null or undefined
            assertParamExists('mediaControllerUploadPublicFinalize', 'uploadFinalizeMediaRequestDTO', uploadFinalizeMediaRequestDTO)
            const localVarPath = `/media/public/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadFinalizeMediaRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload public media
         * @param {UploadInitiateMediaRequestDTO} uploadInitiateMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaControllerUploadPublicInitiate: async (uploadInitiateMediaRequestDTO: UploadInitiateMediaRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadInitiateMediaRequestDTO' is not null or undefined
            assertParamExists('mediaControllerUploadPublicInitiate', 'uploadInitiateMediaRequestDTO', uploadInitiateMediaRequestDTO)
            const localVarPath = `/media/public/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadInitiateMediaRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Finalize media
         * @param {UploadFinalizeMediaRequestDTO} uploadFinalizeMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaControllerUploadFinalize(uploadFinalizeMediaRequestDTO: UploadFinalizeMediaRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFinalizeMediaResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaControllerUploadFinalize(uploadFinalizeMediaRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaControllerUploadFinalize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload media
         * @param {UploadInitiateMediaRequestDTO} uploadInitiateMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaControllerUploadInitiate(uploadInitiateMediaRequestDTO: UploadInitiateMediaRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadInitiateMediaResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaControllerUploadInitiate(uploadInitiateMediaRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaControllerUploadInitiate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Finalize public media
         * @param {UploadFinalizeMediaRequestDTO} uploadFinalizeMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaControllerUploadPublicFinalize(uploadFinalizeMediaRequestDTO: UploadFinalizeMediaRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFinalizeMediaResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaControllerUploadPublicFinalize(uploadFinalizeMediaRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaControllerUploadPublicFinalize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload public media
         * @param {UploadInitiateMediaRequestDTO} uploadInitiateMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaControllerUploadPublicInitiate(uploadInitiateMediaRequestDTO: UploadInitiateMediaRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadInitiateMediaResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaControllerUploadPublicInitiate(uploadInitiateMediaRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaControllerUploadPublicInitiate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * 
         * @summary Finalize media
         * @param {UploadFinalizeMediaRequestDTO} uploadFinalizeMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaControllerUploadFinalize(uploadFinalizeMediaRequestDTO: UploadFinalizeMediaRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<UploadFinalizeMediaResponseDTO> {
            return localVarFp.mediaControllerUploadFinalize(uploadFinalizeMediaRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload media
         * @param {UploadInitiateMediaRequestDTO} uploadInitiateMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaControllerUploadInitiate(uploadInitiateMediaRequestDTO: UploadInitiateMediaRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<UploadInitiateMediaResponseDTO> {
            return localVarFp.mediaControllerUploadInitiate(uploadInitiateMediaRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finalize public media
         * @param {UploadFinalizeMediaRequestDTO} uploadFinalizeMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaControllerUploadPublicFinalize(uploadFinalizeMediaRequestDTO: UploadFinalizeMediaRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<UploadFinalizeMediaResponseDTO> {
            return localVarFp.mediaControllerUploadPublicFinalize(uploadFinalizeMediaRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload public media
         * @param {UploadInitiateMediaRequestDTO} uploadInitiateMediaRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaControllerUploadPublicInitiate(uploadInitiateMediaRequestDTO: UploadInitiateMediaRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<UploadInitiateMediaResponseDTO> {
            return localVarFp.mediaControllerUploadPublicInitiate(uploadInitiateMediaRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     * 
     * @summary Finalize media
     * @param {UploadFinalizeMediaRequestDTO} uploadFinalizeMediaRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaControllerUploadFinalize(uploadFinalizeMediaRequestDTO: UploadFinalizeMediaRequestDTO, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaControllerUploadFinalize(uploadFinalizeMediaRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload media
     * @param {UploadInitiateMediaRequestDTO} uploadInitiateMediaRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaControllerUploadInitiate(uploadInitiateMediaRequestDTO: UploadInitiateMediaRequestDTO, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaControllerUploadInitiate(uploadInitiateMediaRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finalize public media
     * @param {UploadFinalizeMediaRequestDTO} uploadFinalizeMediaRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaControllerUploadPublicFinalize(uploadFinalizeMediaRequestDTO: UploadFinalizeMediaRequestDTO, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaControllerUploadPublicFinalize(uploadFinalizeMediaRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload public media
     * @param {UploadInitiateMediaRequestDTO} uploadInitiateMediaRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaControllerUploadPublicInitiate(uploadInitiateMediaRequestDTO: UploadInitiateMediaRequestDTO, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaControllerUploadPublicInitiate(uploadInitiateMediaRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create New Machine Agent
         * @param {CreateMachineAgentDto} createMachineAgentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerCreateMachineAgent: async (createMachineAgentDto: CreateMachineAgentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMachineAgentDto' is not null or undefined
            assertParamExists('machineAgentControllerCreateMachineAgent', 'createMachineAgentDto', createMachineAgentDto)
            const localVarPath = `/project/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMachineAgentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete machine agent
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerDeleteMachineAgents: async (requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('machineAgentControllerDeleteMachineAgents', 'requestBody', requestBody)
            const localVarPath = `/project/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all machine agent with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerGetMachineAgentByProjectId: async (projectId: string, page: number, limit: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineAgentControllerGetMachineAgentByProjectId', 'projectId', projectId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('machineAgentControllerGetMachineAgentByProjectId', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('machineAgentControllerGetMachineAgentByProjectId', 'limit', limit)
            const localVarPath = `/project/agent/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update machine agent by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerUpdateMachineAgent: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new evaluation test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerAddEvaluationTest: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/evaluationTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create New Machine Model
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerCreateMachineModel: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('machineModelControllerCreateMachineModel', 'body', body)
            const localVarPath = `/project/machineModel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerCreateWebhook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerDeleteEvaluation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/evaluationTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create New Machine Model
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerDeleteMachineModels: async (requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('machineModelControllerDeleteMachineModels', 'requestBody', requestBody)
            const localVarPath = `/project/machineModel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerDeleteWebhook: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('machineModelControllerDeleteWebhook', 'modelId', modelId)
            const localVarPath = `/project/webhook/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute evaluation test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerExecuteEvaluation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/evaluationTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerFetchSwaggerJSON: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('machineModelControllerFetchSwaggerJSON', 'modelId', modelId)
            const localVarPath = `/project/SwaggerJSON/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch webhook
         * @param {string} modelId 
         * @param {boolean} isAgentWebhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerFetchWebhook: async (modelId: string, isAgentWebhook: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('machineModelControllerFetchWebhook', 'modelId', modelId)
            // verify required parameter 'isAgentWebhook' is not null or undefined
            assertParamExists('machineModelControllerFetchWebhook', 'isAgentWebhook', isAgentWebhook)
            const localVarPath = `/project/webhook/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isAgentWebhook !== undefined) {
                localVarQueryParameter['isAgentWebhook'] = isAgentWebhook;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch evaluation test.
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerGetEvaluationTest: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('machineModelControllerGetEvaluationTest', 'modelId', modelId)
            const localVarPath = `/project/evaluationTest/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerGetEventLogsByQueryId: async (modelId: string, queryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('machineModelControllerGetEventLogsByQueryId', 'modelId', modelId)
            // verify required parameter 'queryId' is not null or undefined
            assertParamExists('machineModelControllerGetEventLogsByQueryId', 'queryId', queryId)
            const localVarPath = `/project/queryData/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (queryId !== undefined) {
                localVarQueryParameter['queryId'] = queryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all machine models with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerGetMachineInstanceByProjectId: async (projectId: string, page: number, limit: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineModelControllerGetMachineInstanceByProjectId', 'projectId', projectId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('machineModelControllerGetMachineInstanceByProjectId', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('machineModelControllerGetMachineInstanceByProjectId', 'limit', limit)
            const localVarPath = `/project/machineModel/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerRunQuery: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/runQuery`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerUpdateEvaluation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/evaluationTestUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update machine model by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerUpdateMachineModel: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/machineModel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerUpdateWebhook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add team member to project
         * @param {string} id 
         * @param {AddProjectMemberDto} addProjectMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerAddTeamMemberToProject: async (id: string, addProjectMemberDto: AddProjectMemberDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerAddTeamMemberToProject', 'id', id)
            // verify required parameter 'addProjectMemberDto' is not null or undefined
            assertParamExists('projectControllerAddTeamMemberToProject', 'addProjectMemberDto', addProjectMemberDto)
            const localVarPath = `/project/{id}/team/add`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProjectMemberDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Machine Instance
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreateMachineInstance: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectControllerCreateMachineInstance', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/machineInstance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Project
         * @param {CreateProjectDTO} createProjectDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreateProject: async (createProjectDTO: CreateProjectDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectDTO' is not null or undefined
            assertParamExists('projectControllerCreateProject', 'createProjectDTO', createProjectDTO)
            const localVarPath = `/project/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Project Role
         * @param {string} id 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreateProjectRole: async (id: string, createRoleDto: CreateRoleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerCreateProjectRole', 'id', id)
            // verify required parameter 'createRoleDto' is not null or undefined
            assertParamExists('projectControllerCreateProjectRole', 'createRoleDto', createRoleDto)
            const localVarPath = `/project/{id}/role/create`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete machine instances by ids
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDeleteMachineInstance: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectControllerDeleteMachineInstance', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/machineInstance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDeleteProjectById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerDeleteProjectById', 'id', id)
            const localVarPath = `/project/{id}/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Project Role
         * @param {string} id 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDeleteProjectRole: async (id: string, roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerDeleteProjectRole', 'id', id)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('projectControllerDeleteProjectRole', 'roleId', roleId)
            const localVarPath = `/project/{id}/role/{roleId}/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all project roles
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectRolesDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetAllProjectRoles: async (id: string, page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectRolesDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerGetAllProjectRoles', 'id', id)
            const localVarPath = `/project/{id}/role/all`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (column !== undefined) {
                localVarQueryParameter['column'] = column;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all projects
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetAllProjects: async (page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (column !== undefined) {
                localVarQueryParameter['column'] = column;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all team members of project
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
         * @param {Array<string>} [teamMemberStatus] 
         * @param {Array<number>} [roleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetAllTeamMembersOfProject: async (id: string, page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerGetAllTeamMembersOfProject', 'id', id)
            const localVarPath = `/project/{id}/team/all`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (column !== undefined) {
                localVarQueryParameter['column'] = column;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (teamMemberStatus) {
                localVarQueryParameter['teamMemberStatus'] = teamMemberStatus;
            }

            if (roleIds) {
                localVarQueryParameter['roleIds'] = roleIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get running status of instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetInstanceRunningStatus: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectControllerGetInstanceRunningStatus', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/instanceRunningStatus`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch last 5 notifications
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetLastFiveNotifications: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectControllerGetLastFiveNotifications', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/notifications`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetMachineInstanceByImageId: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectControllerGetMachineInstanceByImageId', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/allMachineInstance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all machineInstances with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetMachineInstanceByUserId: async (projectId: string, page: number, limit: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectControllerGetMachineInstanceByUserId', 'projectId', projectId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('projectControllerGetMachineInstanceByUserId', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('projectControllerGetMachineInstanceByUserId', 'limit', limit)
            const localVarPath = `/project/{projectId}/machineInstance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetProjectById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerGetProjectById', 'id', id)
            const localVarPath = `/project/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project role by id
         * @param {string} id 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetProjectRoleById: async (id: string, roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerGetProjectRoleById', 'id', id)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('projectControllerGetProjectRoleById', 'roleId', roleId)
            const localVarPath = `/project/{id}/role/{roleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user project role
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetUserProjectRole: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerGetUserProjectRole', 'id', id)
            const localVarPath = `/project/{id}/member/role`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark read
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerMarkNotificationsAsRead: async (projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectControllerMarkNotificationsAsRead', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectControllerMarkNotificationsAsRead', 'body', body)
            const localVarPath = `/project/{projectId}/notificationStatus`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project by id
         * @param {string} id 
         * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateProjectById: async (id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerUpdateProjectById', 'id', id)
            // verify required parameter 'updateProjectByIdRequest' is not null or undefined
            assertParamExists('projectControllerUpdateProjectById', 'updateProjectByIdRequest', updateProjectByIdRequest)
            const localVarPath = `/project/{id}/update`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project role by id
         * @param {string} id 
         * @param {number} roleId 
         * @param {UpdateRoleByIdDto} updateRoleByIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateProjectRoleById: async (id: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerUpdateProjectRoleById', 'id', id)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('projectControllerUpdateProjectRoleById', 'roleId', roleId)
            // verify required parameter 'updateRoleByIdDto' is not null or undefined
            assertParamExists('projectControllerUpdateProjectRoleById', 'updateRoleByIdDto', updateRoleByIdDto)
            const localVarPath = `/project/{id}/role/{roleId}/update`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleByIdDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Machine Instance Running Status
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateRunningStatus: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectControllerUpdateRunningStatus', 'body', body)
            const localVarPath = `/project/updateRunningStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update team member
         * @param {string} id 
         * @param {string} teamMemberId 
         * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateTeamMemberRole: async (id: string, teamMemberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerUpdateTeamMemberRole', 'id', id)
            // verify required parameter 'teamMemberId' is not null or undefined
            assertParamExists('projectControllerUpdateTeamMemberRole', 'teamMemberId', teamMemberId)
            // verify required parameter 'updateTeamMemberRequestDTO' is not null or undefined
            assertParamExists('projectControllerUpdateTeamMemberRole', 'updateTeamMemberRequestDTO', updateTeamMemberRequestDTO)
            const localVarPath = `/project/{id}/team/{teamMemberId}/update`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"teamMemberId"}}`, encodeURIComponent(String(teamMemberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamMemberRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join project
         * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateTeamMemberStatus: async (updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateTeamMemberStatusRequestDTO' is not null or undefined
            assertParamExists('projectControllerUpdateTeamMemberStatus', 'updateTeamMemberStatusRequestDTO', updateTeamMemberStatusRequestDTO)
            const localVarPath = `/project/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamMemberStatusRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create New Machine Agent
         * @param {CreateMachineAgentDto} createMachineAgentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerCreateMachineAgent(createMachineAgentDto: CreateMachineAgentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerCreateMachineAgent(createMachineAgentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineAgentControllerCreateMachineAgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete machine agent
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerDeleteMachineAgents(requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerDeleteMachineAgents(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineAgentControllerDeleteMachineAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all machine agent with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerGetMachineAgentByProjectId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerGetMachineAgentByProjectId(projectId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineAgentControllerGetMachineAgentByProjectId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update machine agent by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerUpdateMachineAgent(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerUpdateMachineAgent(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineAgentControllerUpdateMachineAgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new evaluation test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerAddEvaluationTest(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerAddEvaluationTest(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerAddEvaluationTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create New Machine Model
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerCreateMachineModel(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerCreateMachineModel(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerCreateMachineModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerCreateWebhook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerCreateWebhook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerCreateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerDeleteEvaluation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerDeleteEvaluation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerDeleteEvaluation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create New Machine Model
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerDeleteMachineModels(requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerDeleteMachineModels(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerDeleteMachineModels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerDeleteWebhook(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerDeleteWebhook(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerDeleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute evaluation test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerExecuteEvaluation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerExecuteEvaluation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerExecuteEvaluation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerFetchSwaggerJSON(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerFetchSwaggerJSON(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerFetchSwaggerJSON']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch webhook
         * @param {string} modelId 
         * @param {boolean} isAgentWebhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerFetchWebhook(modelId: string, isAgentWebhook: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerFetchWebhook(modelId, isAgentWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerFetchWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch evaluation test.
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerGetEvaluationTest(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerGetEvaluationTest(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerGetEvaluationTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerGetEventLogsByQueryId(modelId: string, queryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerGetEventLogsByQueryId(modelId, queryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerGetEventLogsByQueryId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all machine models with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerGetMachineInstanceByProjectId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerGetMachineInstanceByProjectId(projectId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerGetMachineInstanceByProjectId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Run Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerRunQuery(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerRunQuery(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerRunQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerUpdateEvaluation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerUpdateEvaluation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerUpdateEvaluation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update machine model by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerUpdateMachineModel(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerUpdateMachineModel(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerUpdateMachineModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineModelControllerUpdateWebhook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineModelControllerUpdateWebhook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.machineModelControllerUpdateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add team member to project
         * @param {string} id 
         * @param {AddProjectMemberDto} addProjectMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerAddTeamMemberToProject(id: string, addProjectMemberDto: AddProjectMemberDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddProjectMemberResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerAddTeamMemberToProject(id, addProjectMemberDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerAddTeamMemberToProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Machine Instance
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerCreateMachineInstance(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerCreateMachineInstance(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerCreateMachineInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Project
         * @param {CreateProjectDTO} createProjectDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerCreateProject(createProjectDTO: CreateProjectDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerCreateProject(createProjectDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerCreateProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Project Role
         * @param {string} id 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerCreateProjectRole(id: string, createRoleDto: CreateRoleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectRoleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerCreateProjectRole(id, createRoleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerCreateProjectRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete machine instances by ids
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerDeleteMachineInstance(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerDeleteMachineInstance(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerDeleteMachineInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerDeleteProjectById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteProjectResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerDeleteProjectById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerDeleteProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Project Role
         * @param {string} id 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerDeleteProjectRole(id: string, roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteProjectRoleByIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerDeleteProjectRole(id, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerDeleteProjectRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all project roles
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectRolesDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetAllProjectRoles(id: string, page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectRolesDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllProjectRoleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetAllProjectRoles(id, page, limit, column, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerGetAllProjectRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all projects
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetAllProjects(page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllProjectsResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetAllProjects(page, limit, column, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerGetAllProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all team members of project
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
         * @param {Array<string>} [teamMemberStatus] 
         * @param {Array<number>} [roleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetAllTeamMembersOfProject(id: string, page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllProjectMemberResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetAllTeamMembersOfProject(id, page, limit, column, direction, teamMemberStatus, roleIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerGetAllTeamMembersOfProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get running status of instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetInstanceRunningStatus(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetInstanceRunningStatus(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerGetInstanceRunningStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch last 5 notifications
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetLastFiveNotifications(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetLastFiveNotifications(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerGetLastFiveNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetMachineInstanceByImageId(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetMachineInstanceByImageId(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerGetMachineInstanceByImageId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all machineInstances with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetMachineInstanceByUserId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetMachineInstanceByUserId(projectId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerGetMachineInstanceByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetProjectById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectByIDResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetProjectById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerGetProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project role by id
         * @param {string} id 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetProjectRoleById(id: string, roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectRoleByIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetProjectRoleById(id, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerGetProjectRoleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user project role
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetUserProjectRole(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserProjectRoleByRoleIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetUserProjectRole(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerGetUserProjectRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark read
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerMarkNotificationsAsRead(projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerMarkNotificationsAsRead(projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerMarkNotificationsAsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update project by id
         * @param {string} id 
         * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerUpdateProjectById(id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateProjectByIDResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdateProjectById(id, updateProjectByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerUpdateProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update project role by id
         * @param {string} id 
         * @param {number} roleId 
         * @param {UpdateRoleByIdDto} updateRoleByIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerUpdateProjectRoleById(id: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateProjectRoleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdateProjectRoleById(id, roleId, updateRoleByIdDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerUpdateProjectRoleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Machine Instance Running Status
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerUpdateRunningStatus(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdateRunningStatus(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerUpdateRunningStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update team member
         * @param {string} id 
         * @param {string} teamMemberId 
         * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerUpdateTeamMemberRole(id: string, teamMemberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddProjectMemberResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdateTeamMemberRole(id, teamMemberId, updateTeamMemberRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerUpdateTeamMemberRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Join project
         * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddProjectMemberResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerUpdateTeamMemberStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Create New Machine Agent
         * @param {CreateMachineAgentDto} createMachineAgentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerCreateMachineAgent(createMachineAgentDto: CreateMachineAgentDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerCreateMachineAgent(createMachineAgentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete machine agent
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerDeleteMachineAgents(requestBody: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerDeleteMachineAgents(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all machine agent with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerGetMachineAgentByProjectId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerGetMachineAgentByProjectId(projectId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update machine agent by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerUpdateMachineAgent(options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerUpdateMachineAgent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new evaluation test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerAddEvaluationTest(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineModelControllerAddEvaluationTest(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create New Machine Model
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerCreateMachineModel(body: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineModelControllerCreateMachineModel(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerCreateWebhook(options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.machineModelControllerCreateWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerDeleteEvaluation(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineModelControllerDeleteEvaluation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create New Machine Model
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerDeleteMachineModels(requestBody: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineModelControllerDeleteMachineModels(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerDeleteWebhook(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.machineModelControllerDeleteWebhook(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute evaluation test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerExecuteEvaluation(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineModelControllerExecuteEvaluation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerFetchSwaggerJSON(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineModelControllerFetchSwaggerJSON(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch webhook
         * @param {string} modelId 
         * @param {boolean} isAgentWebhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerFetchWebhook(modelId: string, isAgentWebhook: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.machineModelControllerFetchWebhook(modelId, isAgentWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch evaluation test.
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerGetEvaluationTest(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineModelControllerGetEvaluationTest(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerGetEventLogsByQueryId(modelId: string, queryId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineModelControllerGetEventLogsByQueryId(modelId, queryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all machine models with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerGetMachineInstanceByProjectId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineModelControllerGetMachineInstanceByProjectId(projectId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerRunQuery(options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.machineModelControllerRunQuery(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update evaluation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerUpdateEvaluation(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineModelControllerUpdateEvaluation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update machine model by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerUpdateMachineModel(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineModelControllerUpdateMachineModel(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineModelControllerUpdateWebhook(options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.machineModelControllerUpdateWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add team member to project
         * @param {string} id 
         * @param {AddProjectMemberDto} addProjectMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerAddTeamMemberToProject(id: string, addProjectMemberDto: AddProjectMemberDto, options?: RawAxiosRequestConfig): AxiosPromise<AddProjectMemberResponseDTO> {
            return localVarFp.projectControllerAddTeamMemberToProject(id, addProjectMemberDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Machine Instance
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreateMachineInstance(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectControllerCreateMachineInstance(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Project
         * @param {CreateProjectDTO} createProjectDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreateProject(createProjectDTO: CreateProjectDTO, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectResponseDTO> {
            return localVarFp.projectControllerCreateProject(createProjectDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Project Role
         * @param {string} id 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreateProjectRole(id: string, createRoleDto: CreateRoleDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectRoleResponseDto> {
            return localVarFp.projectControllerCreateProjectRole(id, createRoleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete machine instances by ids
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDeleteMachineInstance(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectControllerDeleteMachineInstance(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDeleteProjectById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteProjectResponseDTO> {
            return localVarFp.projectControllerDeleteProjectById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Project Role
         * @param {string} id 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDeleteProjectRole(id: string, roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteProjectRoleByIdResponseDto> {
            return localVarFp.projectControllerDeleteProjectRole(id, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all project roles
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectRolesDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetAllProjectRoles(id: string, page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectRolesDirectionEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetAllProjectRoleResponseDto> {
            return localVarFp.projectControllerGetAllProjectRoles(id, page, limit, column, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all projects
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetAllProjects(page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetAllProjectsResponseDTO> {
            return localVarFp.projectControllerGetAllProjects(page, limit, column, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all team members of project
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
         * @param {Array<string>} [teamMemberStatus] 
         * @param {Array<number>} [roleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetAllTeamMembersOfProject(id: string, page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<GetAllProjectMemberResponseDto> {
            return localVarFp.projectControllerGetAllTeamMembersOfProject(id, page, limit, column, direction, teamMemberStatus, roleIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get running status of instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetInstanceRunningStatus(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectControllerGetInstanceRunningStatus(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch last 5 notifications
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetLastFiveNotifications(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectControllerGetLastFiveNotifications(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetMachineInstanceByImageId(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectControllerGetMachineInstanceByImageId(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all machineInstances with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetMachineInstanceByUserId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectControllerGetMachineInstanceByUserId(projectId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetProjectById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetProjectByIDResponseDTO> {
            return localVarFp.projectControllerGetProjectById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project role by id
         * @param {string} id 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetProjectRoleById(id: string, roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<GetProjectRoleByIdResponseDto> {
            return localVarFp.projectControllerGetProjectRoleById(id, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user project role
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetUserProjectRole(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUserProjectRoleByRoleIdResponseDto> {
            return localVarFp.projectControllerGetUserProjectRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark read
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerMarkNotificationsAsRead(projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectControllerMarkNotificationsAsRead(projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project by id
         * @param {string} id 
         * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateProjectById(id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateProjectByIDResponseDTO> {
            return localVarFp.projectControllerUpdateProjectById(id, updateProjectByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project role by id
         * @param {string} id 
         * @param {number} roleId 
         * @param {UpdateRoleByIdDto} updateRoleByIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateProjectRoleById(id: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options?: RawAxiosRequestConfig): AxiosPromise<UpdateProjectRoleResponseDto> {
            return localVarFp.projectControllerUpdateProjectRoleById(id, roleId, updateRoleByIdDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Machine Instance Running Status
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateRunningStatus(body: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectControllerUpdateRunningStatus(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update team member
         * @param {string} id 
         * @param {string} teamMemberId 
         * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateTeamMemberRole(id: string, teamMemberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<AddProjectMemberResponseDTO> {
            return localVarFp.projectControllerUpdateTeamMemberRole(id, teamMemberId, updateTeamMemberRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join project
         * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<AddProjectMemberResponseDTO> {
            return localVarFp.projectControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Create New Machine Agent
     * @param {CreateMachineAgentDto} createMachineAgentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineAgentControllerCreateMachineAgent(createMachineAgentDto: CreateMachineAgentDto, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineAgentControllerCreateMachineAgent(createMachineAgentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete machine agent
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineAgentControllerDeleteMachineAgents(requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineAgentControllerDeleteMachineAgents(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all machine agent with count
     * @param {string} projectId 
     * @param {number} page 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineAgentControllerGetMachineAgentByProjectId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineAgentControllerGetMachineAgentByProjectId(projectId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update machine agent by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineAgentControllerUpdateMachineAgent(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineAgentControllerUpdateMachineAgent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new evaluation test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerAddEvaluationTest(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerAddEvaluationTest(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create New Machine Model
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerCreateMachineModel(body: object, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerCreateMachineModel(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerCreateWebhook(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerCreateWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete evaluation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerDeleteEvaluation(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerDeleteEvaluation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create New Machine Model
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerDeleteMachineModels(requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerDeleteMachineModels(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete webhook
     * @param {string} modelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerDeleteWebhook(modelId: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerDeleteWebhook(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute evaluation test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerExecuteEvaluation(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerExecuteEvaluation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch Swagger JSON
     * @param {string} modelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerFetchSwaggerJSON(modelId: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerFetchSwaggerJSON(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch webhook
     * @param {string} modelId 
     * @param {boolean} isAgentWebhook 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerFetchWebhook(modelId: string, isAgentWebhook: boolean, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerFetchWebhook(modelId, isAgentWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch evaluation test.
     * @param {string} modelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerGetEvaluationTest(modelId: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerGetEvaluationTest(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch Swagger JSON
     * @param {string} modelId 
     * @param {string} queryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerGetEventLogsByQueryId(modelId: string, queryId: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerGetEventLogsByQueryId(modelId, queryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all machine models with count
     * @param {string} projectId 
     * @param {number} page 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerGetMachineInstanceByProjectId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerGetMachineInstanceByProjectId(projectId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run Query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerRunQuery(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerRunQuery(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update evaluation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerUpdateEvaluation(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerUpdateEvaluation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update machine model by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerUpdateMachineModel(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerUpdateMachineModel(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public machineModelControllerUpdateWebhook(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).machineModelControllerUpdateWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add team member to project
     * @param {string} id 
     * @param {AddProjectMemberDto} addProjectMemberDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerAddTeamMemberToProject(id: string, addProjectMemberDto: AddProjectMemberDto, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerAddTeamMemberToProject(id, addProjectMemberDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Machine Instance
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerCreateMachineInstance(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerCreateMachineInstance(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Project
     * @param {CreateProjectDTO} createProjectDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerCreateProject(createProjectDTO: CreateProjectDTO, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerCreateProject(createProjectDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Project Role
     * @param {string} id 
     * @param {CreateRoleDto} createRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerCreateProjectRole(id: string, createRoleDto: CreateRoleDto, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerCreateProjectRole(id, createRoleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete machine instances by ids
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerDeleteMachineInstance(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerDeleteMachineInstance(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete project by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerDeleteProjectById(id: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerDeleteProjectById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Project Role
     * @param {string} id 
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerDeleteProjectRole(id: string, roleId: number, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerDeleteProjectRole(id, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all project roles
     * @param {string} id 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [column] 
     * @param {ProjectControllerGetAllProjectRolesDirectionEnum} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerGetAllProjectRoles(id: string, page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectRolesDirectionEnum, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerGetAllProjectRoles(id, page, limit, column, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all projects
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [column] 
     * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerGetAllProjects(page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerGetAllProjects(page, limit, column, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all team members of project
     * @param {string} id 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [column] 
     * @param {ProjectControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
     * @param {Array<string>} [teamMemberStatus] 
     * @param {Array<number>} [roleIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerGetAllTeamMembersOfProject(id: string, page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerGetAllTeamMembersOfProject(id, page, limit, column, direction, teamMemberStatus, roleIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get running status of instances.
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerGetInstanceRunningStatus(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerGetInstanceRunningStatus(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch last 5 notifications
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerGetLastFiveNotifications(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerGetLastFiveNotifications(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get machine id matching instances.
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerGetMachineInstanceByImageId(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerGetMachineInstanceByImageId(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all machineInstances with count
     * @param {string} projectId 
     * @param {number} page 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerGetMachineInstanceByUserId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerGetMachineInstanceByUserId(projectId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerGetProjectById(id: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerGetProjectById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project role by id
     * @param {string} id 
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerGetProjectRoleById(id: string, roleId: number, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerGetProjectRoleById(id, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user project role
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerGetUserProjectRole(id: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerGetUserProjectRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark read
     * @param {string} projectId 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerMarkNotificationsAsRead(projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerMarkNotificationsAsRead(projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project by id
     * @param {string} id 
     * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerUpdateProjectById(id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerUpdateProjectById(id, updateProjectByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project role by id
     * @param {string} id 
     * @param {number} roleId 
     * @param {UpdateRoleByIdDto} updateRoleByIdDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerUpdateProjectRoleById(id: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerUpdateProjectRoleById(id, roleId, updateRoleByIdDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Machine Instance Running Status
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerUpdateRunningStatus(body: object, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerUpdateRunningStatus(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update team member
     * @param {string} id 
     * @param {string} teamMemberId 
     * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerUpdateTeamMemberRole(id: string, teamMemberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerUpdateTeamMemberRole(id, teamMemberId, updateTeamMemberRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join project
     * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ProjectControllerGetAllProjectRolesDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type ProjectControllerGetAllProjectRolesDirectionEnum = typeof ProjectControllerGetAllProjectRolesDirectionEnum[keyof typeof ProjectControllerGetAllProjectRolesDirectionEnum];
/**
 * @export
 */
export const ProjectControllerGetAllProjectsDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type ProjectControllerGetAllProjectsDirectionEnum = typeof ProjectControllerGetAllProjectsDirectionEnum[keyof typeof ProjectControllerGetAllProjectsDirectionEnum];
/**
 * @export
 */
export const ProjectControllerGetAllTeamMembersOfProjectDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type ProjectControllerGetAllTeamMembersOfProjectDirectionEnum = typeof ProjectControllerGetAllTeamMembersOfProjectDirectionEnum[keyof typeof ProjectControllerGetAllTeamMembersOfProjectDirectionEnum];


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get users listing
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {UserControllerFindDirectionEnum} [direction] 
         * @param {UserControllerFindTypeEnum} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFind: async (page?: number, limit?: number, column?: string, direction?: UserControllerFindDirectionEnum, type?: UserControllerFindTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (column !== undefined) {
                localVarQueryParameter['column'] = column;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerGet', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if user is registered
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerIsRegistered: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('userControllerIsRegistered', 'email', email)
            const localVarPath = `/user/{email}/registered`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user data
         * @param {UpdateUserRequestDTO} updateUserRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate: async (updateUserRequestDTO: UpdateUserRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserRequestDTO' is not null or undefined
            assertParamExists('userControllerUpdate', 'updateUserRequestDTO', updateUserRequestDTO)
            const localVarPath = `/user/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user settings
         * @param {UpdateUserSettingsRequestDTO} updateUserSettingsRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSettingsControllerUpdate: async (updateUserSettingsRequestDTO: UpdateUserSettingsRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserSettingsRequestDTO' is not null or undefined
            assertParamExists('userSettingsControllerUpdate', 'updateUserSettingsRequestDTO', updateUserSettingsRequestDTO)
            const localVarPath = `/user/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserSettingsRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get users listing
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {UserControllerFindDirectionEnum} [direction] 
         * @param {UserControllerFindTypeEnum} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFind(page?: number, limit?: number, column?: string, direction?: UserControllerFindDirectionEnum, type?: UserControllerFindTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindUsersResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFind(page, limit, column, direction, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerFind']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserByIdResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMeResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerGetMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if user is registered
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerIsRegistered(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisteredUserResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerIsRegistered(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerIsRegistered']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user data
         * @param {UpdateUserRequestDTO} updateUserRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdate(updateUserRequestDTO: UpdateUserRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserByIdResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(updateUserRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user settings
         * @param {UpdateUserSettingsRequestDTO} updateUserSettingsRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSettingsControllerUpdate(updateUserSettingsRequestDTO: UpdateUserSettingsRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSettingsControllerUpdate(updateUserSettingsRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userSettingsControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Get users listing
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {UserControllerFindDirectionEnum} [direction] 
         * @param {UserControllerFindTypeEnum} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFind(page?: number, limit?: number, column?: string, direction?: UserControllerFindDirectionEnum, type?: UserControllerFindTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<FindUsersResponseDTO> {
            return localVarFp.userControllerFind(page, limit, column, direction, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<GetUserByIdResponseDTO> {
            return localVarFp.userControllerGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMe(options?: RawAxiosRequestConfig): AxiosPromise<GetMeResponseDTO> {
            return localVarFp.userControllerGetMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if user is registered
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerIsRegistered(email: string, options?: RawAxiosRequestConfig): AxiosPromise<RegisteredUserResponseDTO> {
            return localVarFp.userControllerIsRegistered(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user data
         * @param {UpdateUserRequestDTO} updateUserRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate(updateUserRequestDTO: UpdateUserRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<GetUserByIdResponseDTO> {
            return localVarFp.userControllerUpdate(updateUserRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user settings
         * @param {UpdateUserSettingsRequestDTO} updateUserSettingsRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSettingsControllerUpdate(updateUserSettingsRequestDTO: UpdateUserSettingsRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseDTO> {
            return localVarFp.userSettingsControllerUpdate(updateUserSettingsRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Get users listing
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [column] 
     * @param {UserControllerFindDirectionEnum} [direction] 
     * @param {UserControllerFindTypeEnum} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerFind(page?: number, limit?: number, column?: string, direction?: UserControllerFindDirectionEnum, type?: UserControllerFindTypeEnum, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerFind(page, limit, column, direction, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerGet(id: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerGetMe(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerGetMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if user is registered
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerIsRegistered(email: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerIsRegistered(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user data
     * @param {UpdateUserRequestDTO} updateUserRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerUpdate(updateUserRequestDTO: UpdateUserRequestDTO, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerUpdate(updateUserRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user settings
     * @param {UpdateUserSettingsRequestDTO} updateUserSettingsRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSettingsControllerUpdate(updateUserSettingsRequestDTO: UpdateUserSettingsRequestDTO, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userSettingsControllerUpdate(updateUserSettingsRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UserControllerFindDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type UserControllerFindDirectionEnum = typeof UserControllerFindDirectionEnum[keyof typeof UserControllerFindDirectionEnum];
/**
 * @export
 */
export const UserControllerFindTypeEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;
export type UserControllerFindTypeEnum = typeof UserControllerFindTypeEnum[keyof typeof UserControllerFindTypeEnum];


